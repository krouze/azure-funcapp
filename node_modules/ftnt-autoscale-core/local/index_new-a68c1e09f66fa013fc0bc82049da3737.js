'use strict';


exports.handler = async (event, context, callback) =>
    new (initModules().AwsAutoscaleHandler)().handle(event, context, callback);

/**
 * Emulate a module system so we can split this into multiple files later.
 * @TODO: separate into actual separate module files.
 */
function initModules() {
    const modules = {};
    modules.AutoscaleHandler = getAutoscaleHandler();
    modules.LifecycleItem = getLifecycleItem();
    modules.CloudPlatform = getCloudPlatform();
    modules.AwsPlatform = getAwsPlatform(modules.CloudPlatform, modules.LifecycleItem);
    modules.AwsAutoscaleHandler = getAwsAutoscaleHandler(
        modules.AwsPlatform, modules.AutoscaleHandler, modules.LifecycleItem);
    return modules;

    function getCloudPlatform() {
        const notImplemented = () => new Error('Not Implemented');
        /**
         * @abstract
         * Class used to define the capabilities required from cloud platform.
         */
        return class CloudPlatform {
            /* eslint-disable no-unused-vars */
            /**
             * Initialize (and wait for) any required resources such as database tables etc.
             */
            async init() {}

            /**
             * Submit an election vote for this ip address to become the master.
             * @param {String} ip Ip of the fortigate which wants to become the master
             * @param {String} purgeMasterIp Ip of the dead master we should purge before voting
             */
            async putMasterElectionVote(ip, purgeMasterIp) { throw notImplemented() }
            /**
             * Get the ip address which won the master election
             * @returns {String} Ip of the fortigate which should be the auto-sync master
             */
            async getElectedMaster() { throw notImplemented() }
            /**
             * Get an existing lifecyle action from the database.
             * @param {String} instanceId Instance ID of a fortigate.
             * @returns {LifecycleItem} Item used by the platform to complete a
             *  lifecycleAction
             */
            async getPendingLifecycleAction(instanceId) { throw notImplemented() }
            /**
             * Put a new lifecycle action into the database
             * @param {LifecycleItem} item Item used by the platform to complete
             *  a lifecycleAction.
             */
            async putPendingLifecycleAction(item) { throw notImplemented() }
            /**
             * Clean up database the current database entry (or any expired entries)
             * @param {LifecycleItem} [item] Item used to complete a lifecycle
             *  action. When provided, only this item will be cleaned up, otherwise scan for expired
             *  items to purge.
             */
            async cleanUpDb(item = null) { throw notImplemented() }
            /**
             * Get the url for the callback-url portion of the config.
             */
            async getApiGatewayUrl() { throw notImplemented() }

            /**
             * Lookup the instanceid using an ip address.
             * @param {String} ip Local ip address of an instance.
             */
            async findInstanceIdByIp(ip) { throw notImplemented() }

            /**
             * Protect an instance from being scaled out.
             * @param {LifecycleItem} item Item that was used by the platform to complete a
             *  lifecycle action
             * @param {boolean} [protect=true] Whether to add or remove or protection the instance.
             */
            async protectInstanceFromScaleIn(item, protect = true) { throw notImplemented() }
            /* eslint-enable no-unused-vars */
        };
    }

    function getAwsAutoscaleHandler(AwsPlatform, AutoscaleHandler, LifecycleItem) {

        /**
         * Implementation of the AutoscaleHandler for handling requests into the AWS Lambda
         * serverless implementation.
         */
        return class AwsAutoscaleHandler extends AutoscaleHandler {
            constructor() {
                super(new AwsPlatform(), process.env.MASTER_FORTIGATE_CONFIG);
            }

            async handle(event, context, callback) {
                this.step = 'initializing';
                let proxyMethod = 'httpMethod' in event && event.httpMethod;

                try {
                    await this.init();
                    console.log('Event:', event);
                    if (event.source == 'aws.autoscaling') {
                        this.step = 'aws.autoscaling:handleLifecycleAction';
                        callback(null, await this.handleLifecycleAction(event));
                    } else if (proxyMethod === 'POST') {
                        this.step = 'fortigate:handleSyncedCallback';
                        const result = await this.handleSyncedCallback(event);
                        callback(null, proxyResponse(200, result));
                    } else if (proxyMethod === 'GET') {
                        this.step = 'fortigate:getConfig';
                        const result = await this.handleGetConfig(event);
                        callback(null, proxyResponse(200, result));
                    } else {
                        this.step = '¯\\_(ツ)_/¯';

                        console.log(`${this.step} unexpected event!`, event);
                        // probably a test call from the lambda console?
                        callback(null, await this.completeLifecycleAction(event.instanceId));
                    }

                } catch (ex) {
                    if (ex.message) {
                        ex.message = `${this.step}: ${ex.message}`;
                    }
                    console.error('INPUTS: ', event, context);
                    try {
                        console.error('ERROR while ', this.step, proxyMethod, ex);
                    } catch (ex2) {
                        console.error('ERROR while ', this.step, proxyMethod, ex.message, ex, ex2);
                    }
                    if (proxyMethod) {
                        callback(null,
                            proxyResponse(500, {message: ex.message, stack: ex.stack}));
                    } else {
                        callback(ex);
                    }
                }

                function proxyResponse(statusCode, result) {
                    const response = {
                        statusCode,
                        headers: {},
                        body: typeof result === 'string' ? result : JSON.stringify(result),
                        isBase64Encoded: false
                    };
                    return response;
                }

            }

            /* ==== Sub-Handlers ==== */

            /**
             * Store the lifecycle transition event details for use later.
             * @param {AWS.Event} event Event who's source is 'aws.autoscaling'.
             * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/EventTypes.html#auto_scaling_event_types
             */
            async handleLifecycleAction(event) {
                const
                    instanceId = event.detail.EC2InstanceId;

                if (event.detail.LifecycleTransition != 'autoscaling:EC2_INSTANCE_LAUNCHING') {
                    throw new Error(`Wrong LifecycleTransition: ${
                        event.detail.LifecycleTransition}`);
                }

                await this.platform.cleanUpDb();
                const
                    item = new LifecycleItem(instanceId, event.detail),
                    result = await this.platform.putPendingLifecycleAction(item);

                console.log(`Callback pending for ${event.detail.EC2InstanceId} (token ${
                    event.detail.LifecycleActionToken})`);
                return result;
            }

            /**
             * Handle the 'auto-scale synced' callback from the fortigate.
             * @param {AWS.ProxyIntegrationEvent} event Event from the api-gateway.
             * @see https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format
             */
            async handleSyncedCallback(event) {
                const instanceId = await this.findCallingInstanceId(event);
                const success = JSON.parse(event.body).status === 'success';
                return await this.completeLifecycleAction(instanceId, success);
            }

            /**
             * Handle the 'getConfig' callback from the fortigate.
             * @param {Aws.ProxyIntegrationEvent} event Event from the api-gateway.
             * @see https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format
             */
            async handleGetConfig(event) {
                const
                    ip = this.findCallingInstanceIp(event);
                return await this.getConfig(ip);
            }

            /* ==== Utilities ==== */

            findCallingInstanceIp(request) {
                return (request.headers && request.headers['X-Forwarded-For']) ||
                    (request.requestContext && request.requestContext.identity &&
                    request.requestContext.identity.sourceIp);
            }

            async findCallingInstanceId(request) {
                const localIp = this.findCallingInstanceIp(request);
                if (!localIp) {
                    throw Error('X-Forwarded-For and requestContext do not contain the instance local ip');
                }
                return await this.platform.findInstanceIdByIp(localIp);
            }

        };
    }

    function getLifecycleItem() {
        /**
         * Contains all the relevant information needed to complete lifecycle actions for a given
         * fortigate instance, as well as info needed to clean up the related database entry.
         */
        return class LifecycleItem {
            /**
             * @param {String} instanceId Id of the fortigate instance.
             * @param {Object} detail Opaque information used by the platform to manage this item.
             * @param {Date} [timestamp=Date.now()] Optional timestamp for this record.
             */
            constructor(instanceId, detail, timestamp = null) {
                this.instanceId = instanceId;
                this.timestamp = timestamp || Date.now();
                this.detail = detail;
            }

            /**
             * Return a POJO DB entry with capitalized properties.. (not sure why)
             */
            toDb() {
                return {
                    FortigateInstance: this.instanceId,
                    Timestamp: this.timestamp,
                    Detail: this.detail
                };

            }

            /**
             * Resucitate from a stored DB entry
             * @param {Object} entry Entry from DB
             * @returns {LifecycleItem} A new lifecycle item.
             */
            static fromDb(entry) {
                return new LifecycleItem(entry.FortigateInstance, entry.Detail, entry.Timestamp);
            }
        };
    }

    function getAutoscaleHandler() {

        const
            AUTOSCALE_SECTION_EXPR =
                /(?:^|\n)\s*config?\s*system?\s*auto-scale[\s\n]*((?:.|\n)*)\bend\b/,
            SET_SECRET_EXPR = /(set\s+(?:psksecret|password)\s+).*/g;

        /**
         * AutoscaleHandler contains the core used to handle serving configuration files and
         * manage the autoscale events from multiple cloud platforms.
         *
         * Use this class in various serverless cloud contexts. For each serverless cloud
         * implementation extend this class and implement the handle() method. The handle() method
         * should call other methods as needed based on the input events from that cloud's
         * autoscale mechanism and api gateway requests from the fortigate's callback-urls.
         * (see reference AWS implementation {@link AwsAutoscaleHandler})
         *
         * Each cloud implementation should also implement a concrete version of the abstract
         * {@link CloudPlatform} class which should be passed to super() in the constructor. The
         * CloudPlatform interface should abstract each specific cloud's api. The reference
         * implementation {@link AwsPlatform} handles access to the dynamodb for persistence and
         * locking, interacting with the aws autoscaling api and determining the api endpoint url
         * needed for the fortigate config's callback-url parameter.
         */
        class AutoscaleHandler {

            constructor(platform, baseConfig) {
                this.platform = platform;
                this._baseConfig = baseConfig;
            }

            async handle() { throw new Error('Not Implemented') }

            async init() {
                await this.platform.init();
            }

            async getConfig(ip) {
                this.step = 'handler:getConfig:holdElection';
                const
                    masterIp = await this.holdMasterElection(ip);
                if (masterIp == ip) {

                    this.step = 'handler:getConfig:completeMaster';
                    await this.completeMasterInstance(await this.platform.findInstanceIdByIp(ip));

                    this.step = 'handler:getConfig:getMasterConfig';
                    return await this.getMasterConfig();
                } else {

                    this.step = 'handler:getConfig:getSlaveConfig';
                    return await this.getSlaveConfig(masterIp);
                }
            }

            async getMasterConfig() {
                return this._baseConfig.replace(/\$\{CALLBACK_URL}/,
                    await this.platform.getApiGatewayUrl());
            }

            async getSlaveConfig(masterIp) {
                const
                    autoScaleSectionMatch = AUTOSCALE_SECTION_EXPR
                        .exec(await this._baseConfig),
                    autoScaleSection = autoScaleSectionMatch && autoScaleSectionMatch[1],
                    matches = [
                        /set\s+sync-interface\s+(.+)/.exec(autoScaleSection),
                        /set\s+psksecret\s+(.+)/.exec(autoScaleSection)
                    ];
                const
                    [syncInterface, pskSecret] = matches.map(m => m && m[1]),
                    apiEndpoint = await this.platform.getApiGatewayUrl(),
                    config = `
                        diag sys ha hadiff log enable
                        diag debug app hasync -1
                        diag debug enable
                        config system auto-scale
                            set status enable
                            set sync-interface ${syncInterface}
                            set role slave
                            set master-ip ${masterIp}
                            set callback-url ${apiEndpoint}
                            set psksecret ${pskSecret}
                        end
                        config system dns
                            unset primary
                            unset secondary
                        end
                        config system global
                            set admin-console-timeout 300
                        end
                    `;
                if (!syncInterface || !pskSecret) {
                    throw new Error(`Base config is invalid: ${
                        JSON.stringify({
                            syncInterface, apiEndpoint, masterIp,
                            pskSecret: pskSecret && typeof pskSecret
                        })}`);
                }
                if (!apiEndpoint) {
                    throw new Error('Api endpoint is missing');
                }
                if (!masterIp) {
                    throw new Error('Master ip is missing');
                }
                console.log('Slave config: ', config.replace(SET_SECRET_EXPR, '$1 *'));
                return config;
            }

            async holdMasterElection(ip) {
                let masterIp;
                try {
                    masterIp = await this.platform.getElectedMaster();
                } catch (ex) {
                    console.log(ex.message);
                }
                const masterInstanceId =
                    masterIp && await this.platform.findInstanceIdByIp(masterIp);
                if (!masterInstanceId || !masterIp) {
                    console.log(!masterIp ?
                        'no master, maybe I will be the new master?' :
                        'master is dead, long live the master');
                    await this.platform.putMasterElectionVote(ip, masterIp);
                    masterIp = await this.platform.getElectedMaster();
                }
                console.log(ip === masterIp ? `Election won! new master is ${masterIp}` :
                    `${ip} lost the election, master is ${masterIp}`);
                return masterIp;
            }

            async completeLifecycleAction(instanceId, success = true) {
                const
                    item = await this.platform.getPendingLifecycleAction(instanceId),
                    data = await this.platform.completeLifecycleAction(item, success);

                await this.platform.cleanUpDb(item);
                return {item, data};
            }

            async completeMasterInstance(instanceId) {
                const
                    {item, result} = await this.completeLifecycleAction(instanceId, true);
                let instanceProtected = false;
                try {
                    instanceProtected = await this.platform.protectInstanceFromScaleIn(item);
                } catch (ex) {
                    console.error('Unable to protect instance from scale in:');
                    console.error(ex);
                }
                console.log(`Lifecycle for master ${instanceId} has been completed. ` +
                    `Protected: ${instanceProtected}`);
                return result;
            }
        }

        return AutoscaleHandler;
    }

    function getAwsPlatform(CloudPlatform, LifecycleItem) {
        const
            AWS = require('aws-sdk'),
            EXPIRE_LIFECYCLE_ENTRY = (process.env.EXPIRE_LIFECYCLE_ENTRY || 60 * 60) * 1000;

        // lock the API versions
        AWS.config.apiVersions = {
            autoscaling: '2011-01-01',
            ec2: '2016-11-15',
            lambda: '2015-03-31',
            dynamodb: '2012-08-10',
            apiGateway: '2015-07-09'
        };
        const
            autoScaling = new AWS.AutoScaling(),
            dynamodb = new AWS.DynamoDB(),
            docClient = new AWS.DynamoDB.DocumentClient(),
            ec2 = new AWS.EC2(),
            apiGateway = new AWS.APIGateway(),
            id = process.env.UNIQUE_ID.replace(/.*\//, ''),
            DB = {
                AUTOSCALE: {
                    AttributeDefinitions: [
                        {
                            AttributeName: 'FortigateInstance',
                            AttributeType: 'S'
                        }
                    ],
                    KeySchema: [
                        {
                            AttributeName: 'FortigateInstance',
                            KeyType: 'HASH'
                        }
                    ],
                    ProvisionedThroughput: {
                        ReadCapacityUnits: 1,
                        WriteCapacityUnits: 1
                    },
                    TableName: `FortigateAutoscale-${id}`
                },
                ELECTION: {
                    AttributeDefinitions: [
                        {
                            AttributeName: 'Master',
                            AttributeType: 'S'
                        }
                    ],
                    KeySchema: [
                        {
                            AttributeName: 'Master',
                            KeyType: 'HASH'
                        }
                    ],
                    ProvisionedThroughput: { ReadCapacityUnits: 1, WriteCapacityUnits: 1 },
                    TableName: `FortigateMasterElection-${id}`
                }
            };

        /**
         * Implements the CloudPlatform abstraction for the AWS api.
         */
        return class AwsPlatform extends CloudPlatform {
            async init() {
                // TODO: create these as a custom resource instead?
                await Promise.all([createTable(DB.AUTOSCALE), createTable(DB.ELECTION)]);

                async function createTable(schema) {
                    try {
                        await dynamodb.describeTable({TableName: schema.TableName}).promise();
                        console.log('found table', schema.TableName);
                    } catch (ex) {
                        console.log('creating table ', schema.TableName);
                        await dynamodb.createTable(schema).promise();
                    }
                    await dynamodb.waitFor('tableExists', {TableName: schema.TableName}).promise();
                }
            }

            // unfortunately we can't link up the api gateway id during CFT stack creation as it
            // would create a cycle. Grab it by looking up the rest api name passed as a parameter
            async getApiGatewayUrl() {
                let position,
                    page;
                const
                    gwName = process.env.API_GATEWAY_NAME,
                    region = process.env.AWS_REGION,
                    stage = process.env.API_GATEWAY_STAGE_NAME,
                    resource = process.env.API_GATEWAY_RESOURCE_NAME;
                do {

                    this.step = 'handler:getApiGatewayUrl:getRestApis';
                    page = await apiGateway.getRestApis({position}).promise();
                    position = page.position;
                    const
                        gw = page.items.find(i => i.name === gwName);
                    if (gw) {
                        return `https://${gw.id}.execute-api.${region}.amazonaws.com/` +
                            `${stage}/${resource}`;
                    }
                } while (page.items.length);
                throw new Error(`Api Gateway not found looking for ${gwName}`);
            }

            async getPendingLifecycleAction(instanceId) {
                const query = {
                        TableName: DB.AUTOSCALE.TableName,
                        Key: { FortigateInstance: instanceId }
                    },
                    response = await docClient.get(query).promise(),
                    item = response.Item;
                if (!item) {
                    throw new Error(
                        `Could not find LifecycleActionToken for instance ${instanceId}`);
                }
                return LifecycleItem.fromDb(item);
            }
            /**
             * @param {LifecycleItem} item Item containing the data to store.
             */
            async putPendingLifecycleAction(item) {
                const params = {
                    TableName: DB.AUTOSCALE.TableName,
                    Item: item.toDb()
                };
                return await docClient.put(params).promise();
            }

            async cleanUpDb(item = null) {
                try {
                    const tableName = DB.AUTOSCALE.TableName;
                    if (item == null) {
                        const
                            response = await dynamodb.scan({TableName: tableName, Limit: 5})
                                .promise(),
                            items = response.Items;
                        if (items && items.length) {
                            items.forEach(async i => await this.cleanUpDb(i));
                        }
                    } else if (Date.now() - item.Timestamp > EXPIRE_LIFECYCLE_ENTRY) {
                        console.log('cleaning up old entry: ' +
                            `${item.instanceId} (${(Date.now() - item.Timestamp) / 1000}s ago`);
                        await docClient.delete({
                            TableName: tableName,
                            Key: { FortigateInstance: item.instanceId }
                        });
                    }
                } catch (ex) {
                    console.error('Error while cleaning up (ignored):', ex);
                }
            }

            /**
             * Get the ip address which won the master election
             * @returns {String} Ip of the fortigate which should be the auto-sync master
             */
            async getElectedMaster() {
                const
                    query = {
                        TableName: DB.ELECTION.TableName,
                        Key: {Master: 'master'}
                    },
                    response = await docClient.get(query).promise(),
                    item = response.Item;
                if (!item) {
                    throw Error('No elected master was found in the db!', response);
                }
                return item.Ip;
            }

            /**
             * Submit an election vote for this ip address to become the master.
             * @param {String} ip Ip of the fortigate which wants to become the master
             * @param {String} purgeMasterIp Ip of the old master, if it's dead.
             */
            async putMasterElectionVote(ip, purgeMasterIp = null) {
                try {
                    const params = {
                        TableName: DB.ELECTION.TableName,
                        Item: {Master: 'master', Ip: ip},
                        ConditionExpression: 'attribute_not_exists(Master)'
                    };
                    console.log('masterElectionVote, purge master?', purgeMasterIp);
                    if (purgeMasterIp) {
                        const purgeParams = {
                            TableName: DB.ELECTION.TableName,
                            Key: {Master: 'master'},
                            ConditionExpression: 'Ip = :ip',
                            ExpressionAttributeValues: {
                                ':ip': purgeMasterIp
                            }
                        };
                        const purged = await docClient.delete(purgeParams).promise();
                        console.log('purged: ', purged);
                    } else {
                        console.log('no master purge');
                    }
                    return await docClient.put(params).promise();
                } catch (ex) {
                    console.warn('exception while putMasterElectionVote',
                        ip, purgeMasterIp, ex.stack);
                }
            }

            /**
             * @param {LifecycleItem} item Item from the db containing data
             *  needed by the platform to complete the lifecycle action.
             * @param {boolean} success Whether the action should be completed or aborted.
             */
            async completeLifecycleAction(item, success) {
                console.log('completeLifecycleAction(', item, ', ', success, ')');
                const detail = item.detail;
                var params = {
                    AutoScalingGroupName: detail.AutoScalingGroupName,
                    LifecycleActionResult: success ? 'CONTINUE' : 'ABANDON' ,
                    LifecycleActionToken: detail.LifecycleActionToken,
                    LifecycleHookName: detail.LifecycleHookName
                    // InstanceId: event.instanceId
                };
                const data = await autoScaling.completeLifecycleAction(params).promise();
                console.log(
                    `${params.LifecycleActionResult} applied to ${params.LifecycleHookName}:${
                        params.LifecycleActionToken}`);
                return data;
            }

            async findInstanceIdByIp(localIp) {
                if (!localIp) {
                    throw new Error('Cannot find instance by Ip because ip is invalid: ', localIp);
                }
                const params = {Filters: [{
                    Name: 'private-ip-address',
                    Values: [localIp]
                }]};
                const result = await ec2.describeInstances(params).promise();
                console.log(localIp, 'DescribeInstances', result);
                const instance = result.Reservations[0] && result.Reservations[0].Instances[0];
                return instance && instance.InstanceId;
            }

            async protectInstanceFromScaleIn(item, protect = true) {
                const
                    MAX_TRIES = 10,
                    // Delay the attempt to setInstanceProtection because it takes around a second
                    // for autoscale to switch the instance to `InService` status.
                    PROTECT_DELAY = 2000;
                let count = 0;
                while (true) { // eslint-disable-line no-constant-condition
                    try {
                        await runAfter(PROTECT_DELAY, () => autoScaling.setInstanceProtection({
                            AutoScalingGroupName: item.detail.AutoScalingGroupName,
                            InstanceIds: [item.instanceId],
                            ProtectedFromScaleIn: protect !== false
                        }).promise());
                        return true;
                    } catch (ex) {
                        if (/\bnot in InService\b/.test(ex.message) && count < MAX_TRIES) {
                            ++count;
                            console.log(`${ex.message} while protecting ${item.instanceId}: ` +
                                `(trying again ${count}/${MAX_TRIES})`);
                        } else {
                            throw ex;
                        }
                    }
                }

                async function runAfter(interval, callback) {
                    const precision = Math.max(0, 3 - Math.log10(interval / 100));
                    console.log(`Delaying for ${(interval / 1000).toFixed(precision)}s > `,
                        callback.toString()
                            .replace(/.*(?:function|=>)\s*(.*?)(?:[(\n]|$)(?:\n|.)*/, '$1'));
                    return new Promise(resolve => setTimeout(() => resolve(callback()), interval));
                }
            }
        };
    }
}
